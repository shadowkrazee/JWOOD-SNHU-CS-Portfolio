# JWOOD-SNHU-CS-Portfolio

# CS 225 - System Analysis and Design

`More to come soon...`

# CS 250 - Software Development Life Cycle

`How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?`

The process of requirements gathering helps to distill functional requirements from discussions with users and other stakeholders into a simple checklist. Assembling that checklist into user stories aids in the tracking of progress, and testing whether or not the users' needs are met by the product.

`How do I approach developing programs? What agile processes do I hope to incorporate into my future development work?`

Application development is the process of building a solution to meet a set of specifications. The iterative approach of agile methodologies helps to deliver value in small increments over time, rather than attempting to build the whole solution in one "long sprint". This allows for gradual progress towards the customers' goals, without the risk that the end product is not what the customer envisioned from the beginning. I have, and will continue to implement an iterative approach to my personal projects and business endeavors.

`What does it mean to be a good team member in software development?`

A good team member is someone who does their part, helps others, and does their best to ensure that the work they produce helps to push the poject as a whole in the right direction.

# CS 230 - Operating Platforms

`Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?`

The Gaming Room was a CTS client that sought to create a multi-platform game called "Draw It or Lose It", allowing players on desktop and mobile platforms to play together in a "Win, Lose, or Draw" style game where players attempt to guess the subject of a drawing as it is gradually uncovered. The game supported team and solo play, a web version, and IOS and Android applications, and was fun to work on.

`What did you do particularly well in developing this documentation?`

I would say that I did a good job of comparing traditional operating platforms and devlopment practices with their cloud-based alternatives, and made the most appropriate, cost-effective recommendations based on the client's goals.

`What about the process of working through a design document did you find helpful when developing the code?`

The documentation served to organize my thoughts and ideas in a way that made it easier to understand end-to-end than if I were to have tried to imagine it all up in my head. This organization and planning overall leads to a better solution by allowing "the vision" to be seen by others, reviewed by the client, and adapted until all parties are happy with the plan and development can begin.

`If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?`

I think I'd like to review the entire document as a whole and work to make it more cohesive. It feels as if it were developed in several independent sections, rather than as one large project.

`How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?`

The goal of any software is to provide value to the user, either as a tool, a service, or entertainment. If a project doesn't consider the user's needs and experience as part of development, it's sure to underwhelm, and not likely to suceed.

`How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?`

My approach was largely experience based. The client's goals were pretty well in line with some projects I have worked on, so I applied that knowledge to create a solution for the Gaming Room. In the future, I will try to do more research before jumping for the "tried and true" easy answer, to ensure that I am providing the best solution for the client, and not just the easiest solution for me to implement.
